---
title: "FirstMarkdown"
author: "Alexander Kissonergis"
date: "2024-01-25"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


#we can use LaTeX to create proper looking equations and. greek symbols using two $ operators on either side of the equation, see notes in the online lecture series, specifically the Markdown lectures. EX: $$xxxxxxx$$


#Sometimes we want to mix the mathematical symbols with plain text font, to do this in LaTeX we must use a structure called "mbox" to keep the string separate from being considered a variable. 

#you can embed LaTeX in line $\pi + 3$ as such
#we can also use markdown fencing in line with a single backtick `pi + 3`
#see notes for the difference in the above two, the second does not show the greek symbol for pi

#we can even execute r code inside of markdown text with `r pi + 3` this will return the output of pi + 3


```{r} 
#this creates an r chunk 

install.packages("tinytex")
install.packages(TeachingDemos)

Pred <- seq(1,10)  #make a vector of integers from 1 to 10
Res <- runif(10)   #generate 10 draws from a random uniform (0,1) distribution

#print the random numbers
print(Res)

char2seed("green tea")
char2seed("green tea", set=FALSE)

#Global Variables
nRep <- 10000
```

CTRL RET
-to run a single line of code

CTRL SHIFT RETURN
-to source and echo entire script

CTRL SHIFT S
-executed the entire script, gives us source command (without echo), the only output is something that used the print function

CTRL SHIFT C
-comment and un comment selected lines of code

```{r}
#first chunk

print(pi)
pi + 3

```

How to use REGEX

SEE NOTES ON REGEX LECTURE !!!

Atomic Vectors Lecture 2.1.24

```{r}
x <- 5 
y = 4 

y = y + 1.1
print(y)

y <- y + 1.1
print(y)
```

```{r}
z <- 3
plantHeight <- 10 # option "cameCaseFormatting
plant.height <- 4.2 # avoid periods
plant_height < 3.3 # optimal snake_case_formatting
. <- #reserve this for a generic temporary variable (more later)
```

```{r}
z <- c(3.2,5,5,6)
print(z)
typeof(z)
is.numeric(z)

z <- c(c(3,4),c(5,6))
print(z)

z <- c("perch", "bass", 'carp')
print(z)

z <- c("This is only 'one' character string", "now a second")
print(z)
typeof(z)
is.character(z)

z <- c(TRUE, TRUE, FALSE)

print(z)
typeof(z)
is.logical(z)
is.integer(z)

dogs <- c("chow", "pug", "beagle", "greyhound", "akita")

dogs[1] #picks first element
dogs[5] #picks fifth element
dogs[6] # NA, but not an error

dogs[c(3,5)]

dogs[c(1,1,1,4)] #works fine with mulitple repeats

#grab entire list with blank brackets
dogs[]

my_dogs <- c(1,4)

dogs[my_dogs]

dogs[length(dogs)]

#use negative numbers to EXCLUDE elements
dogs[-1]

#ok to use multiple negations
dogs[c(-2,-4)]
dogs[-c(2,4)]

#can't mix positive and negative elements in brackets
#dogs[c(1,-5)]


#THREE PROPERTIES OF A VECTOR

#SEE NOTES FROM ATOMIC VECTOR LECTURE

#ALL aatomics are of the same type
# if they are different, R coerces them 
# logical -> integer -> double _. character

a <- c(2,2.0)
print(a)
typeof(a)

b <- c("purple","green")
typeof(b)

d <- c(a,b)
print(d)
typeof(d)
       
# Mistakes in numerical variables convert to strings
# Very useful when working with logical variables

a <- runif(10)
print(a)

# Comparison operators yield a logical result
a > 0.5

#do math on a logical and it coerces to an integer

# sHow many elements are greater than 0.5?
sum (a > 0.5)

#what proportion of the vector elements are greater than 0.5?

mean(a > 0.5)

#break down the results

. <- a > 0.5
print(.)
. <- as.integer(.)
print(.)
print(sum(.))
print(mean(.))

#Qualifying exam question! Aprox. what proportion of observations drawn from a normal (0,1) distribution are larger than 2.0?

mean(rnorm(1000) > 2)
print(sum(.))
print(mean(.))

#adding a constant to a vector
z <- c(10,20,30)
z + 1

y <- c(1,2,3)
z+y

#results is an element by element operation on the vector 
#most vector operations can be done this way

z^2

#but what if vector lengths are noth equal? 
z <- c(10,20,30)
x <- c(1,2)
z + x
```

```{r}
#Atomic Vectors II 06 February 2024

#create an empty vector, specify mode and length
z<- vector(mode="numeric", length=0)
print(z)

#This dynamic sizing is VERY SLOW!

# has 100 0's in a numeric vector
z <- rep(0,100)
length(z)
head(z)
tail(z)

z[c(50,51,52)]

# but would be better to start with NAs and NOT zeros
z <- rep(NA,100)
head(z)

typeof(z)

# take advantage of coercion!
z[1] <- "Washington"
head(z)
typeof(z)

my_vector <-runif(100)
my_names <-paste("Species",seq(1:length(my_vector)), sep="")
head(my_names)
names(my_vector) <- my_names
head(my_vector)
str(my_vector)

# rep for repeating elements
rep(0.5,6) #give the elements (or vector) and number of times to repeat
rep(x=0.5, times=6) #using the argument names is always prudent
rep(times=6, x=0.5) #with argument names order is not important
my_vec <- c(1,2,3)
rep(x+my_vec,times=2) #apples to entire vectors
rep(x+my_vec,each=2) #repeat each element individually
rep(x+my_vec,times=my_vec) #what does this do?
rep(x+my_vec,each=my_vec) #and this?
rep(x=my_vec,each=c(3,2,1)) #and this?

seq(from=2, to=4) #set limits for integer sequences
2:4 #very common shortcut with no explicit function wrappers
seq(from=2,to=4,by=0.5) # use a by function can generate real numbers
x <- seq(from=2, to=4, length=7) #sometimes easier to just specify the length
my_vec <- 1:length(x) #commonly used, but actually slow
print(my_vec)
seq_along(my_vec) # much faster for models and big data! 
seq_len(5) #this is also faster than 1:5

#for further notes on using a random uniform function see notes on ATOMIC VECTOR II online

#continued, see above
```